let _gl, gl;
let lapse = 0;
let _if = 1;
let _skbg = 1;
let _node; 
let buttonLayer; 
let buttons = []; 

// tessellation
const MINIMUM_DISTANCE = 4;
let _drawer;
let _tessellator;

let hui;

let buttonRecipe =
    [{name:"delete", x:30, y:60, w:90, h:20, col:[78,100,100]},  // 0
    {name:"clear", x:30, y:90, w:90, h:20, col:[84,100,100]},
    {name:"create", x:30, y:140, w:90, h:40, col:[55,100,100]},
    {name:"reset", x:30,y:190, w:90, h:20, col:[45,100,100]},
    {name:"BOARD", x:30, y:240, w:90, h:20, col:[96,100,30]},    // 4
    {name:"BEVEL", x:30, y:270, w:90, h:20, col:[6,100,30]},
    {name:"DIMPLE", x:30, y:300, w:90, h:20, col:[16,100,30]},
    {name:"SPLIT", x:30, y:330, w:90, h:20, col:[26,100,30]},
    {name:"FIX", x:140, y:240, w:90, h:20, col:[46, 100, 30]},  
    {name:"ROLLING", x:140, y:270, w:90, h:20, col:[56, 100, 30]},
    {name:"MOVE", x:140, y:300, w:90, h:20, col:[40, 100, 30]}, // 10
    {name:"BOARD", x:30, y:240, w:90, h:20, col:[96,100,100]},   // 11
    {name:"BEVEL", x:30, y:270, w:90, h:20, col:[6,100,100]},
    {name:"DIMPLE", x:30, y:300, w:90, h:20, col:[16,100,100]},
    {name:"SPLIT", x:30, y:330, w:90, h:20, col:[26,100,100]},
    {name:"FIX", x:140, y:240, w:90, h:20, col:[46, 100, 100]},
    {name:"ROLLING", x:140, y:270, w:90, h:20, col:[56, 100, 100]},
    {name:"MOVE", x:140, y:300, w:90, h:20, col:[40, 100, 100]},   // 17
    {name:"CAMERA", x:140, y:60, w:90, h:50, col:[52, 100, 30]}, // 18
    {name:"CAMERA", x:140, y:60, w:90, h:50, col:[52, 100, 100]} // 19
   ];

// x:<235,y:55～125

let cameraFlag = false;


const MODE_BOARD = 0;
const MODE_BEVEL = 1;
const MODE_DIMPLE = 2;
const MODE_SPLIT = 3;
let sliderImg; 
let sliderFlag = [false, false]; 

// ACTION TYPE.
const ACTION_FIX = 0; 
const ACTION_ROLLING = 1; 
const ACTION_MOVE = 2; 


let posR = 320*Math.sqrt(3);
let defaultPosR = 320 * Math.sqrt(3);
let posTheta = Math.PI * 0.4;
let posPhi = Math.PI*0.66;
let focusX = 0;
let focusY = 0;
let eyeVector, toCenterVector, sideVector, upVector;

// --------------------------------------------------------------- //
// shader.

let lightVert=
"precision mediump float;" +

"attribute vec3 aPosition;" +
"attribute vec4 aVertexColor;" +
"attribute vec3 aNormal;" +

"uniform vec3 uAmbientColor;" +

"uniform mat4 uModelViewMatrix;" +
"uniform mat4 uProjectionMatrix;" +
"uniform mat3 uNormalMatrix;" +

"varying vec4 vVertexColor;" +
"varying vec3 vNormal;" +
"varying vec3 vViewPosition;" +
"varying vec3 vAmbientColor;" +

"void main(void){" +
 
"  vec4 viewModelPosition = uModelViewMatrix * vec4(aPosition, 1.0);" +

  // Pass varyings to fragment shader
"  vViewPosition = viewModelPosition.xyz;" +
"  gl_Position = uProjectionMatrix * viewModelPosition;" +

"  vNormal = uNormalMatrix * aNormal;" +
"  vVertexColor = aVertexColor;" +

"  vAmbientColor = uAmbientColor;" +
"}";

let lightFrag =
"precision mediump float;" +

"uniform mat4 uViewMatrix;" +
// directionalLight
"uniform vec3 uLightingDirection;" +
"uniform vec3 uDirectionalDiffuseColor;" +
"uniform vec3 uPointLightLocation;" +
"uniform vec3 uPointLightDiffuseColor;" +
"uniform vec3 uAttenuation;" + 
// pointLight
"uniform bool uUseDirectionalLight;" + // false.
"uniform bool uUsePointLight;" + // false;

"const float diffuseFactor = 0.73;" +
"const int USE_VERTEX_COLOR = 0;" +
"const int USE_MONO_COLOR = 1;" +
// DirectionalLight
"vec3 getDirectionalLightDiffuseColor(vec3 normal){" +
"  vec3 lightVector = (uViewMatrix * vec4(uLightingDirection, 0.0)).xyz;" +
"  vec3 lightDir = normalize(lightVector);" +
"  vec3 lightColor = uDirectionalDiffuseColor;" +
"  float diffuse = max(0.0, dot(-lightDir, normal));" +
"  return diffuse * lightColor;" +
"}" +
// PointLight attenuation
"vec3 getPointLightDiffuseColor(vec3 modelPosition, vec3 normal){" +
"  vec3 lightPosition = (uViewMatrix * vec4(uPointLightLocation, 1.0)).xyz;" +
"  vec3 lightVector = modelPosition - lightPosition;" +
"  vec3 lightDir = normalize(lightVector);" +
"  float lightDistance = length(lightVector); " +
"  float d = lightDistance;" +
"  float lightFallOff = 1.0 / dot(uAttenuation, vec3(1.0, d, d*d));" +
"  vec3 lightColor = lightFallOff * uPointLightDiffuseColor;" +
"  float diffuse = max(0.0, dot(-lightDir, normal));" +
"  return diffuse * lightColor;" +
"}" +
// _lightはこれで。
"vec3 totalLight(vec3 modelPosition, vec3 normal){" +
"  vec3 result = vec3(0.0);" + // 0.0
// directionalLight
"  if(uUseDirectionalLight){" +
"    result += getDirectionalLightDiffuseColor(normal);" +
"  }" +
// pointLight
"  if(uUsePointLight){" +
"    result += getPointLightDiffuseColor(modelPosition, normal);" +
"  }" +
"  result *= diffuseFactor;" +
"  return result;" +
"}" +
// include lighting.glsl
"uniform vec4 uMonoColor;" +
"uniform int uUseColorFlag;" + // 0:vertex. 1:mono.

"varying vec4 vVertexColor;" +
"varying vec3 vNormal;" +
"varying vec3 vViewPosition;" +
"varying vec3 vAmbientColor;" +


"void main(void){" +
"  vec3 diffuse = totalLight(vViewPosition, normalize(vNormal));" +
"  vec4 col = vec4(1.0);" +

"  if(uUseColorFlag == USE_MONO_COLOR) {" +
"    col = uMonoColor;" +  // uMonoColor
"  }" +
"  if(uUseColorFlag == USE_VERTEX_COLOR){" +
"    col = vVertexColor;" + 
"  }" +
  // diffuseの分
"  col.rgb *= (diffuse + vAmbientColor);" +
"  gl_FragColor = col;" +
"}";

let myVert=
"precision mediump float;" +
"attribute vec3 aPosition;" +
"attribute vec4 aVertexColor;" +
"varying vec4 vVertexColor;" +
"uniform mat4 uModelViewMatrix;" +
"uniform mat4 uProjectionMatrix;" +
"void main(){" +
"  vec4 viewModelPosition = uModelViewMatrix * vec4(aPosition, 1.0);" +
"  gl_Position = uProjectionMatrix * viewModelPosition;" +
"  vVertexColor = aVertexColor;" +
"}";

let myFrag=
"precision mediump float;" +
"varying vec4 vVertexColor;" +
"void main(){" +
"  gl_FragColor = vVertexColor;" +
"}";

const skyVert =
"precision mediump float;" +
"attribute vec3 aPosition;" +
"void main(){" +
"  gl_Position = vec4(aPosition, 1.0);" +
"}";


const skyFrag =
"precision mediump float;" +
"uniform vec2 uResolution;" +
"uniform float uFov;" + 
"uniform float uAspect;" + 
"uniform vec3 uEye;" + 
"uniform vec3 uToCenter;" + 
"uniform vec3 uSide;" + // x.
"uniform vec3 uUp;" + // -y.
// getRGB.
"vec3 getRGB(float h, float s, float b){" +
"  vec3 c = vec3(h, s, b);" +
"  vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);" +
"  rgb = rgb * rgb * (3.0 - 2.0 * rgb);" +
"  return c.z * mix(vec3(1.0), rgb, c.y);" +
"}" +

"vec3 getSkyColor(vec3 eye, vec3 ray){" +
"  float z = ray.z + 0.05;" +
"  vec3 skyColor = getRGB(0.65, sqrt(z * (2.0 - z)), 1.0);" +
"  return skyColor;" +
"}" +

"vec3 getBackgroundColor(vec3 eye, vec3 ray){" +
"  if(ray.z > -0.05){" +
"    return getSkyColor(eye, ray);" +
"  }" +
"  float t = -eye.z / ray.z;" +
"  vec2 q = eye.xy + t * ray.xy;" +
"  vec2 iq = floor(q/80.0);" +
"  vec3 result;" +
"  if(mod(iq.x + iq.y, 2.0) == 0.0){" +
"    result = getRGB(0.55, 0.8, 1.0); }else{" +
"    result = getRGB(0.55, 0.3, 1.0); }" +
"  if(max(abs(iq.x), abs(iq.y)) > 20.0){ result = getRGB(0.55, 0.55, 1.0); }" +
"  return result;" +
"}" +

"void main(){" +
"  vec2 p = (gl_FragCoord.xy * 2.0 - uResolution.xy) / uResolution.xy;" +
// pを(-1,-1)～(1,1)にする
// eyetoCenter
// side x aspect x tan(fov/2)
// -up x tan(fov/2) 
"  vec3 cur = uEye;" +
"  vec3 ray = uToCenter;" +
"  ray += p.x * uAspect * tan(uFov * 0.5) * uSide;" +
"  ray -= p.y * tan(uFov * 0.5) * uUp;" +
"  vec3 col = getBackgroundColor(cur, ray);" +
"  gl_FragColor = vec4(col, 1.0);" +
"}";


function setup() {
  _gl = createCanvas(1112, windowHeight, WEBGL);
  pixelDensity(1);
  gl = _gl.GL; 

  
  gl.enable(gl.CULL_FACE);
  gl.cullFace(gl.FRONT);
  disableScroll();
	
  textureFloatCheck();
  Uint32ArrayCheck();
	noStroke();
	
	// Add a button to save screenshots
	button = createButton('SAVE');
  button.position(180, 330);
	button.size(90,20);
  button.mousePressed(saver);
	button.style("padding", "0px 0");
	button.style('text-align','left');
  button.style("color", "#bbbbbb");
  button.style("background-color", "#dd0000");
  button.style("font-size", 18+"px");
	button.style("border", "0");
  button.style("font-weight", "bold"); // bold
  button.style("font-family", "Helvetica,sans-serif");
	
  // Add a button to toggle interface on-off
	button2 = createButton('INTRFACE');
  button2.position(180, 140);
	button2.size(90,20);
  button2.mousePressed(inter);
	button2.style("padding", "0px 0");
	button2.style('text-align','left');
  button2.style("color", "#cccccc");
  button2.style("background-color", "#dd7700");
  button2.style("font-size", 18+"px");
	button2.style("border", "0");
  //button2.style("font-weight", "bold"); // bold
  button2.style("font-family", "Helvetica,sans-serif");
	
	// Add a button to toggle sky / white bg
	button3 = createButton('SKY/WHT');
  button3.position(180, 190);
	button3.size(90,20);
  button3.mousePressed(skywhite);
	button3.style("padding", "0px 0");
	button3.style('text-align','left');
  button3.style("color", "#444444");
  button3.style("background-color", "#bbbb00");
  button3.style("font-size", 18+"px");
	button3.style("border", "0");
  //button3.style("font-weight", "bold"); // bold
  button3.style("font-family", "Helvetica,sans-serif");


  _node = new RenderNode();

  _shader = createShader(lightVert, lightFrag);
  _node.registRenderSystem('light', _shader);

 
  _drawer = new Drawer();
  _tessellator = new Tessellator();
  _tessellator.setPaintHue(0.05, 0.15);
  

  document.oncontextmenu = (e) => {
    e.preventDefault();
  }

  buttonLayer = new BackgroundManager();

  

  createConfigButtons();

  buttonLayer.addLayer().addLayer();
  preDrawingButtons();
  preDrawingExplainTexts();
  createSliderImage();
  

  focusX = 0;
  focusY = 0;
  focusZ = height * 0.5;
  posR = height * 0.5 * Math.sqrt(3);
  defaultPosR = height * 0.5 * Math.sqrt(3);

	// this shader creates the sky background
  _shader = createShader(skyVert, skyFrag);
  _node.registRenderSystem('sky', _shader);
  _node.use('sky', 'plane')
       .registAttribute('aPosition', [-1,1,0,1,1,0,-1,-1,0,1,-1,0], 3);
  
  eyeVector = createVector();
  toCenterVector = createVector();
  sideVector = createVector();
  upVector = createVector();

  // 90,130,170,240,280,320,360.
  

  /*
  let p = [];
  for(let i = 0; i < 800; i++){
    const t = TAU*i/800;
    const x = 160*(cos(16*t)-0.75*sin(9*t));
    const y = 160*(sin(16*t)-0.75*cos(9*t));
    p.push(x, y, 0);
  }
  _drawer.contours.push(p);
  p=[];
  */
  //_drawer.contours = getContoursFromText(hui,"", 240, 5, CENTER, CENTER);
  //_drawer.contours.push([80,80,0,-80,80,0,-80,-80,0,80,-80,0]);

  /*
  let p = [];
  p.push(-200,-200,0,-100,-200,0,-100,200,0,0,200,0,
         0,-200,0,100,-200,0,100,200,0,200,200,0,
         200,100,0,-200,100,0,-200,0,0,200,0,0,200,-100,0,-200,-100,0);
    _drawer.contours.push(p);
 
 
  //_drawer.contours.push([-100,-100,0,100,-100,0,100,100,0,-100,100,0]);
  //_drawer.contours.push([0.1,-100,0,0.1,100,0,-0.1,100,0,-0.1,-100,0]);
  //_drawer.contours.push([100,35-0.1,0,100,35+0.1,0,-100,-78-0.1,0,-100,-78+0.1,0]);
  //_drawer.contours.push([23-0.1,-100,0,23+0.1,-100,0,79+0.1,100,0,79-0.1,100,0]);
 
}

// --------------------------------------------------------------- //
// main loop.

let performanceRatio = 0;

function draw(){
  background(255);
  const start = millis();
  _drawer.update();


 //_drawer.img.setLayer(0)
  //           .draw("background", [0])
  //           .setLayer(1)
  //           .draw("clear");


  if(cameraFlag){ moveCamera(); }
  eyeVector.set(posR*sin(posTheta)*sin(posPhi)+focusX,
                posR*sin(posTheta)*cos(posPhi)+focusY,
                posR*cos(posTheta)+focusZ);
  camera(eyeVector.x, eyeVector.y, eyeVector.z, focusX, focusY, focusZ, 0, 0, -1);
  const m = _gl.uMVMatrix.copy().mat4;
  toCenterVector.set(-m[2], -m[6], -m[10]);
  sideVector.set(m[0], m[4], m[8]);
  upVector.set(m[1], m[5], m[9]);


  gl.disable(gl.DEPTH_TEST);
  camera(0, 0, height * 0.5 * Math.sqrt(3.0), 0, 0, 0, 0, 1, 0);
  if (_skbg == 1){
	_node.use('sky', 'plane')
       .setAttribute()
       .setUniform("uResolution", [width, height])
       .setUniform("uFov", Math.PI / 3)
       .setUniform("uAspect", width / height)
       .setUniform("uEye", [eyeVector.x, eyeVector.y, eyeVector.z])
       .setUniform("uToCenter", [toCenterVector.x, toCenterVector.y, toCenterVector.z])
       .setUniform("uSide", [sideVector.x, sideVector.y, sideVector.z])
       .setUniform("uUp", [upVector.x, upVector.y, upVector.z])
       .drawArrays(gl.TRIANGLE_STRIP)
       .clear();
	}
  gl.enable(gl.DEPTH_TEST);
  
  _drawer.display();
  _node.useRenderSystem('light')
       .setDirectionalLight(_RGB(1), 0, 0, -1)
       .setAmbientLight(_RGB(0.25));
  

  camera(eyeVector.x, eyeVector.y, eyeVector.z, focusX, focusY, focusZ, 0, 0, -1);

  _tessellator.setTranslate(focusX, focusY, focusZ);
  _tessellator.setRotation(-posPhi, -posTheta);
  _tessellator.display();
  
  _drawer.img.setLayer(0)
             .draw("clear")
             .setLayer(1)
             .draw("clear");
             /*.draw("text", [performanceRatio.toFixed(3), 16, 16]);*/

  _drawer.display();

const modeId = _tessellator.getMode();
  const activeModeButtonId = 11 + modeId;
  const activeModeButton = buttons[activeModeButtonId];
  const actionId = _tessellator.getAction();
  const activeActionButtonId = 15 + actionId;
  const activeActionButton = buttons[activeActionButtonId];
  
  
  buttonLayer.setLayer(0)
             .draw("clear")
             .setLayer(2)
             .draw("clear")
             .draw("image", [activeModeButton.img, activeModeButton.x, activeModeButton.y])
             .draw("image", [activeActionButton.img, activeActionButton.x, activeActionButton.y]);
  
  if(cameraFlag){
    buttonLayer.draw("image", [buttons[19].img, buttons[19].x, buttons[19].y]);
  }
  
  
  sliderUpdate();
  const hues = _tessellator.getPaintHue();
  const upperY = 60 + hues.u * 100;
  const lowerY = 180 + hues.l * 100;
  buttonLayer.draw("image", [sliderImg, 3, upperY])
             .draw("image", [sliderImg, 3, lowerY]);
  
  if (_if == 1) buttonLayer.display();  // allows hiding of button interface
  
  // step.
  const end = millis();
  performanceRatio = (end - start) * 60 / 1000;
}

// --------------------------------------------------------------- //
// config.

function preDrawingButtons(){
  buttonLayer.setLayer(1);  
  for(let i = 0; i < 11; i++){ 
    const btn = buttons[i];
    buttonLayer.draw("image", [btn.img, btn.x, btn.y]);
  }
  const btn = buttons[18];
  buttonLayer.draw("image", [btn.img, btn.x, btn.y]);
