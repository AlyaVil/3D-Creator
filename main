let _gl, gl;
let lapse = 0;
let _if = 1;
let _skbg = 1;
let _node; 
let buttonLayer; 
let buttons = []; 

// tessellation
const MINIMUM_DISTANCE = 4;
let _drawer;
let _tessellator;

let hui;

let buttonRecipe =
    [{name:"delete", x:30, y:60, w:90, h:20, col:[78,100,100]},  // 0
    {name:"clear", x:30, y:90, w:90, h:20, col:[84,100,100]},
    {name:"create", x:30, y:140, w:90, h:40, col:[55,100,100]},
    {name:"reset", x:30,y:190, w:90, h:20, col:[45,100,100]},
    {name:"BOARD", x:30, y:240, w:90, h:20, col:[96,100,30]},    // 4
    {name:"BEVEL", x:30, y:270, w:90, h:20, col:[6,100,30]},
    {name:"DIMPLE", x:30, y:300, w:90, h:20, col:[16,100,30]},
    {name:"SPLIT", x:30, y:330, w:90, h:20, col:[26,100,30]},
    {name:"FIX", x:140, y:240, w:90, h:20, col:[46, 100, 30]},  
    {name:"ROLLING", x:140, y:270, w:90, h:20, col:[56, 100, 30]},
    {name:"MOVE", x:140, y:300, w:90, h:20, col:[40, 100, 30]}, // 10
    {name:"BOARD", x:30, y:240, w:90, h:20, col:[96,100,100]},   // 11
    {name:"BEVEL", x:30, y:270, w:90, h:20, col:[6,100,100]},
    {name:"DIMPLE", x:30, y:300, w:90, h:20, col:[16,100,100]},
    {name:"SPLIT", x:30, y:330, w:90, h:20, col:[26,100,100]},
    {name:"FIX", x:140, y:240, w:90, h:20, col:[46, 100, 100]},
    {name:"ROLLING", x:140, y:270, w:90, h:20, col:[56, 100, 100]},
    {name:"MOVE", x:140, y:300, w:90, h:20, col:[40, 100, 100]},   // 17
    {name:"CAMERA", x:140, y:60, w:90, h:50, col:[52, 100, 30]}, // 18
    {name:"CAMERA", x:140, y:60, w:90, h:50, col:[52, 100, 100]} // 19
   ];

// x:<235,y:55～125

let cameraFlag = false;


const MODE_BOARD = 0;
const MODE_BEVEL = 1;
const MODE_DIMPLE = 2;
const MODE_SPLIT = 3;
let sliderImg; 
let sliderFlag = [false, false]; 

// ACTION TYPE.
const ACTION_FIX = 0; 
const ACTION_ROLLING = 1; 
const ACTION_MOVE = 2; 


let posR = 320*Math.sqrt(3);
let defaultPosR = 320 * Math.sqrt(3);
let posTheta = Math.PI * 0.4;
let posPhi = Math.PI*0.66;
let focusX = 0;
let focusY = 0;
let eyeVector, toCenterVector, sideVector, upVector;

// --------------------------------------------------------------- //
// shader.

let lightVert=
"precision mediump float;" +

"attribute vec3 aPosition;" +
"attribute vec4 aVertexColor;" +
"attribute vec3 aNormal;" +

"uniform vec3 uAmbientColor;" +

"uniform mat4 uModelViewMatrix;" +
"uniform mat4 uProjectionMatrix;" +
"uniform mat3 uNormalMatrix;" +

"varying vec4 vVertexColor;" +
"varying vec3 vNormal;" +
"varying vec3 vViewPosition;" +
"varying vec3 vAmbientColor;" +

"void main(void){" +
 
"  vec4 viewModelPosition = uModelViewMatrix * vec4(aPosition, 1.0);" +

  // Pass varyings to fragment shader
"  vViewPosition = viewModelPosition.xyz;" +
"  gl_Position = uProjectionMatrix * viewModelPosition;" +

"  vNormal = uNormalMatrix * aNormal;" +
"  vVertexColor = aVertexColor;" +

"  vAmbientColor = uAmbientColor;" +
"}";

let lightFrag =
"precision mediump float;" +

"uniform mat4 uViewMatrix;" +
// directionalLight
"uniform vec3 uLightingDirection;" +
"uniform vec3 uDirectionalDiffuseColor;" +
"uniform vec3 uPointLightLocation;" +
"uniform vec3 uPointLightDiffuseColor;" +
"uniform vec3 uAttenuation;" + 
// pointLight
"uniform bool uUseDirectionalLight;" + // false.
"uniform bool uUsePointLight;" + // false;

"const float diffuseFactor = 0.73;" +
"const int USE_VERTEX_COLOR = 0;" +
"const int USE_MONO_COLOR = 1;" +
// DirectionalLight
"vec3 getDirectionalLightDiffuseColor(vec3 normal){" +
"  vec3 lightVector = (uViewMatrix * vec4(uLightingDirection, 0.0)).xyz;" +
"  vec3 lightDir = normalize(lightVector);" +
"  vec3 lightColor = uDirectionalDiffuseColor;" +
"  float diffuse = max(0.0, dot(-lightDir, normal));" +
"  return diffuse * lightColor;" +
"}" +
// PointLight attenuation
"vec3 getPointLightDiffuseColor(vec3 modelPosition, vec3 normal){" +
"  vec3 lightPosition = (uViewMatrix * vec4(uPointLightLocation, 1.0)).xyz;" +
"  vec3 lightVector = modelPosition - lightPosition;" +
"  vec3 lightDir = normalize(lightVector);" +
"  float lightDistance = length(lightVector); " +
"  float d = lightDistance;" +
"  float lightFallOff = 1.0 / dot(uAttenuation, vec3(1.0, d, d*d));" +
"  vec3 lightColor = lightFallOff * uPointLightDiffuseColor;" +
"  float diffuse = max(0.0, dot(-lightDir, normal));" +
"  return diffuse * lightColor;" +
"}" +
// _lightはこれで。
"vec3 totalLight(vec3 modelPosition, vec3 normal){" +
"  vec3 result = vec3(0.0);" + // 0.0
// directionalLight
"  if(uUseDirectionalLight){" +
"    result += getDirectionalLightDiffuseColor(normal);" +
"  }" +
// pointLight
"  if(uUsePointLight){" +
"    result += getPointLightDiffuseColor(modelPosition, normal);" +
"  }" +
"  result *= diffuseFactor;" +
"  return result;" +
"}" +
// include lighting.glsl
"uniform vec4 uMonoColor;" +
"uniform int uUseColorFlag;" + // 0:vertex. 1:mono.

"varying vec4 vVertexColor;" +
"varying vec3 vNormal;" +
"varying vec3 vViewPosition;" +
"varying vec3 vAmbientColor;" +


"void main(void){" +
"  vec3 diffuse = totalLight(vViewPosition, normalize(vNormal));" +
"  vec4 col = vec4(1.0);" +

"  if(uUseColorFlag == USE_MONO_COLOR) {" +
"    col = uMonoColor;" +  // uMonoColor
"  }" +
"  if(uUseColorFlag == USE_VERTEX_COLOR){" +
"    col = vVertexColor;" + 
"  }" +
  // diffuseの分
"  col.rgb *= (diffuse + vAmbientColor);" +
"  gl_FragColor = col;" +
"}";

let myVert=
"precision mediump float;" +
"attribute vec3 aPosition;" +
"attribute vec4 aVertexColor;" +
"varying vec4 vVertexColor;" +
"uniform mat4 uModelViewMatrix;" +
"uniform mat4 uProjectionMatrix;" +
"void main(){" +
"  vec4 viewModelPosition = uModelViewMatrix * vec4(aPosition, 1.0);" +
"  gl_Position = uProjectionMatrix * viewModelPosition;" +
"  vVertexColor = aVertexColor;" +
"}";

let myFrag=
"precision mediump float;" +
"varying vec4 vVertexColor;" +
"void main(){" +
"  gl_FragColor = vVertexColor;" +
"}";

const skyVert =
"precision mediump float;" +
"attribute vec3 aPosition;" +
"void main(){" +
"  gl_Position = vec4(aPosition, 1.0);" +
"}";


const skyFrag =
"precision mediump float;" +
"uniform vec2 uResolution;" +
"uniform float uFov;" + 
"uniform float uAspect;" + 
"uniform vec3 uEye;" + 
"uniform vec3 uToCenter;" + 
"uniform vec3 uSide;" + // x.
"uniform vec3 uUp;" + // -y.
// getRGB.
"vec3 getRGB(float h, float s, float b){" +
"  vec3 c = vec3(h, s, b);" +
"  vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);" +
"  rgb = rgb * rgb * (3.0 - 2.0 * rgb);" +
"  return c.z * mix(vec3(1.0), rgb, c.y);" +
"}" +

"vec3 getSkyColor(vec3 eye, vec3 ray){" +
"  float z = ray.z + 0.05;" +
"  vec3 skyColor = getRGB(0.65, sqrt(z * (2.0 - z)), 1.0);" +
"  return skyColor;" +
"}" +

"vec3 getBackgroundColor(vec3 eye, vec3 ray){" +
"  if(ray.z > -0.05){" +
"    return getSkyColor(eye, ray);" +
"  }" +
"  float t = -eye.z / ray.z;" +
"  vec2 q = eye.xy + t * ray.xy;" +
"  vec2 iq = floor(q/80.0);" +
"  vec3 result;" +
"  if(mod(iq.x + iq.y, 2.0) == 0.0){" +
"    result = getRGB(0.55, 0.8, 1.0); }else{" +
"    result = getRGB(0.55, 0.3, 1.0); }" +
"  if(max(abs(iq.x), abs(iq.y)) > 20.0){ result = getRGB(0.55, 0.55, 1.0); }" +
"  return result;" +
"}" +

"void main(){" +
"  vec2 p = (gl_FragCoord.xy * 2.0 - uResolution.xy) / uResolution.xy;" +
// pを(-1,-1)～(1,1)にする
// eyetoCenter
// side x aspect x tan(fov/2)
// -up x tan(fov/2) 
"  vec3 cur = uEye;" +
"  vec3 ray = uToCenter;" +
"  ray += p.x * uAspect * tan(uFov * 0.5) * uSide;" +
"  ray -= p.y * tan(uFov * 0.5) * uUp;" +
"  vec3 col = getBackgroundColor(cur, ray);" +
"  gl_FragColor = vec4(col, 1.0);" +
"}";


function setup() {
  _gl = createCanvas(1112, windowHeight, WEBGL);
  pixelDensity(1);
  gl = _gl.GL; 

  
  gl.enable(gl.CULL_FACE);
  gl.cullFace(gl.FRONT);
  disableScroll();
	
  textureFloatCheck();
  Uint32ArrayCheck();
	noStroke();
	
	// Add a button to save screenshots
	button = createButton('SAVE');
  button.position(180, 330);
	button.size(90,20);
  button.mousePressed(saver);
	button.style("padding", "0px 0");
	button.style('text-align','left');
  button.style("color", "#bbbbbb");
  button.style("background-color", "#dd0000");
  button.style("font-size", 18+"px");
	button.style("border", "0");
  button.style("font-weight", "bold"); // bold
  button.style("font-family", "Helvetica,sans-serif");
	
  // Add a button to toggle interface on-off
	button2 = createButton('INTRFACE');
  button2.position(180, 140);
	button2.size(90,20);
  button2.mousePressed(inter);
	button2.style("padding", "0px 0");
	button2.style('text-align','left');
  button2.style("color", "#cccccc");
  button2.style("background-color", "#dd7700");
  button2.style("font-size", 18+"px");
	button2.style("border", "0");
  //button2.style("font-weight", "bold"); // bold
  button2.style("font-family", "Helvetica,sans-serif");
	
	// Add a button to toggle sky / white bg
	button3 = createButton('SKY/WHT');
  button3.position(180, 190);
	button3.size(90,20);
  button3.mousePressed(skywhite);
	button3.style("padding", "0px 0");
	button3.style('text-align','left');
  button3.style("color", "#444444");
  button3.style("background-color", "#bbbb00");
  button3.style("font-size", 18+"px");
	button3.style("border", "0");
  //button3.style("font-weight", "bold"); // bold
  button3.style("font-family", "Helvetica,sans-serif");


  _node = new RenderNode();

  _shader = createShader(lightVert, lightFrag);
  _node.registRenderSystem('light', _shader);

 
  _drawer = new Drawer();
  _tessellator = new Tessellator();
  _tessellator.setPaintHue(0.05, 0.15);
  

  document.oncontextmenu = (e) => {
    e.preventDefault();
  }

  buttonLayer = new BackgroundManager();

  

  createConfigButtons();

  buttonLayer.addLayer().addLayer();
  preDrawingButtons();
  preDrawingExplainTexts();
  createSliderImage();
  

  focusX = 0;
  focusY = 0;
  focusZ = height * 0.5;
  posR = height * 0.5 * Math.sqrt(3);
  defaultPosR = height * 0.5 * Math.sqrt(3);

	// this shader creates the sky background
  _shader = createShader(skyVert, skyFrag);
  _node.registRenderSystem('sky', _shader);
  _node.use('sky', 'plane')
       .registAttribute('aPosition', [-1,1,0,1,1,0,-1,-1,0,1,-1,0], 3);
  
  eyeVector = createVector();
  toCenterVector = createVector();
  sideVector = createVector();
  upVector = createVector();

  // 90,130,170,240,280,320,360.
  

  /*
  let p = [];
  for(let i = 0; i < 800; i++){
    const t = TAU*i/800;
    const x = 160*(cos(16*t)-0.75*sin(9*t));
    const y = 160*(sin(16*t)-0.75*cos(9*t));
    p.push(x, y, 0);
  }
  _drawer.contours.push(p);
  p=[];
  */
  //_drawer.contours = getContoursFromText(hui,"", 240, 5, CENTER, CENTER);
  //_drawer.contours.push([80,80,0,-80,80,0,-80,-80,0,80,-80,0]);

  /*
  let p = [];
  p.push(-200,-200,0,-100,-200,0,-100,200,0,0,200,0,
         0,-200,0,100,-200,0,100,200,0,200,200,0,
         200,100,0,-200,100,0,-200,0,0,200,0,0,200,-100,0,-200,-100,0);
    _drawer.contours.push(p);
 
 
  //_drawer.contours.push([-100,-100,0,100,-100,0,100,100,0,-100,100,0]);
  //_drawer.contours.push([0.1,-100,0,0.1,100,0,-0.1,100,0,-0.1,-100,0]);
  //_drawer.contours.push([100,35-0.1,0,100,35+0.1,0,-100,-78-0.1,0,-100,-78+0.1,0]);
  //_drawer.contours.push([23-0.1,-100,0,23+0.1,-100,0,79+0.1,100,0,79-0.1,100,0]);
 
}

// --------------------------------------------------------------- //
// main loop.

let performanceRatio = 0;

function draw(){
  background(255);
  const start = millis();
  _drawer.update();


 //_drawer.img.setLayer(0)
  //           .draw("background", [0])
  //           .setLayer(1)
  //           .draw("clear");


  if(cameraFlag){ moveCamera(); }
  eyeVector.set(posR*sin(posTheta)*sin(posPhi)+focusX,
                posR*sin(posTheta)*cos(posPhi)+focusY,
                posR*cos(posTheta)+focusZ);
  camera(eyeVector.x, eyeVector.y, eyeVector.z, focusX, focusY, focusZ, 0, 0, -1);
  const m = _gl.uMVMatrix.copy().mat4;
  toCenterVector.set(-m[2], -m[6], -m[10]);
  sideVector.set(m[0], m[4], m[8]);
  upVector.set(m[1], m[5], m[9]);


  gl.disable(gl.DEPTH_TEST);
  camera(0, 0, height * 0.5 * Math.sqrt(3.0), 0, 0, 0, 0, 1, 0);
  if (_skbg == 1){
	_node.use('sky', 'plane')
       .setAttribute()
       .setUniform("uResolution", [width, height])
       .setUniform("uFov", Math.PI / 3)
       .setUniform("uAspect", width / height)
       .setUniform("uEye", [eyeVector.x, eyeVector.y, eyeVector.z])
       .setUniform("uToCenter", [toCenterVector.x, toCenterVector.y, toCenterVector.z])
       .setUniform("uSide", [sideVector.x, sideVector.y, sideVector.z])
       .setUniform("uUp", [upVector.x, upVector.y, upVector.z])
       .drawArrays(gl.TRIANGLE_STRIP)
       .clear();
	}
  gl.enable(gl.DEPTH_TEST);
  
  _drawer.display();
  _node.useRenderSystem('light')
       .setDirectionalLight(_RGB(1), 0, 0, -1)
       .setAmbientLight(_RGB(0.25));
  

  camera(eyeVector.x, eyeVector.y, eyeVector.z, focusX, focusY, focusZ, 0, 0, -1);

  _tessellator.setTranslate(focusX, focusY, focusZ);
  _tessellator.setRotation(-posPhi, -posTheta);
  _tessellator.display();
  
  _drawer.img.setLayer(0)
             .draw("clear")
             .setLayer(1)
             .draw("clear");
             /*.draw("text", [performanceRatio.toFixed(3), 16, 16]);*/

  _drawer.display();

const modeId = _tessellator.getMode();
  const activeModeButtonId = 11 + modeId;
  const activeModeButton = buttons[activeModeButtonId];
  const actionId = _tessellator.getAction();
  const activeActionButtonId = 15 + actionId;
  const activeActionButton = buttons[activeActionButtonId];
  
  
  buttonLayer.setLayer(0)
             .draw("clear")
             .setLayer(2)
             .draw("clear")
             .draw("image", [activeModeButton.img, activeModeButton.x, activeModeButton.y])
             .draw("image", [activeActionButton.img, activeActionButton.x, activeActionButton.y]);
  
  if(cameraFlag){
    buttonLayer.draw("image", [buttons[19].img, buttons[19].x, buttons[19].y]);
  }
  
  
  sliderUpdate();
  const hues = _tessellator.getPaintHue();
  const upperY = 60 + hues.u * 100;
  const lowerY = 180 + hues.l * 100;
  buttonLayer.draw("image", [sliderImg, 3, upperY])
             .draw("image", [sliderImg, 3, lowerY]);
  
  if (_if == 1) buttonLayer.display();  // allows hiding of button interface
  
  // step.
  const end = millis();
  performanceRatio = (end - start) * 60 / 1000;
}

// --------------------------------------------------------------- //
// config.

function preDrawingButtons(){
  buttonLayer.setLayer(1);  
  for(let i = 0; i < 11; i++){ 
    const btn = buttons[i];
    buttonLayer.draw("image", [btn.img, btn.x, btn.y]);
  }
  const btn = buttons[18];
  buttonLayer.draw("image", [btn.img, btn.x, btn.y]);

 let csd = createGraphics(20, 100);
  csd.colorMode(HSB, 100);
  csd.noStroke();
  for(let i = 0; i < 100; i++){
    csd.fill(i, 100, 100);
    csd.rect(0, i, 100, 1);
  }
  buttonLayer.draw("image", [csd, 5, 60]);
  buttonLayer.draw("image", [csd, 5, 180]);
}

function preDrawingExplainTexts(){
  buttonLayer.setLayer(1)
             .draw("fill", [0])
             .draw("noStroke")
             .draw("textSize", [24])
             .draw("textAlign", [CENTER, CENTER]);
             /*.draw("text", ["drawing: mouseLeftDown", width*0.5,height*0.45])
             .draw("text", ["create: mouseRightDown", width*0.5,height*0.45+30]);*/
}

// strokeHilight
function createConfigButton(rcp, strokeHilight = false){
  let gr = createGraphics(rcp.w, rcp.h);
  gr.colorMode(HSB, 100);
  gr.textSize(18);
  gr.textAlign(LEFT, CENTER);
  gr.noStroke();
  gr.fill(...rcp.col);
  gr.rect(0, 0, rcp.w, rcp.h);
  gr.fill(0);
  if(strokeHilight){ gr.fill(64); }
  gr.text(rcp.name, rcp.w*0.01, rcp.h*0.5);
  buttons.push({img:gr, x:rcp.x, y:rcp.y});
}

function createConfigButtons(){
  for(let i = 0; i < 20; i++){ 
  
    const strokeHilight = ((i>=4 && i<=10) || (i==18));
    createConfigButton(buttonRecipe[i], strokeHilight);
  }
}

function saver(){
  save("img_" + month() + '-' + day() + '_' + hour() + '-' + minute() + '-' + second() + ".jpg");
}

function inter(){
  _if = 1 - _if;
}

function disableScroll() { 
  // Get the current page scroll position 
  scrollTop = window.pageYOffset || document.documentElement.scrollTop; 
  scrollLeft = window.pageXOffset || document.documentElement.scrollLeft, 
  
  // if any scroll is attempted, set this to the previous value 
  window.onscroll = function() { 
    window.scrollTo(scrollLeft, scrollTop); 
  }; 
} 

function skywhite(){
  _skbg = 1 - _skbg;
}

function createSliderImage(){
  sliderImg = createGraphics(24, 10);
  sliderImg.stroke(255);
  sliderImg.strokeWeight(2);
  sliderImg.fill(128);
  sliderImg.rect(1, 1, 22, 8);
}

function sliderUpdate(){
  if(!mouseIsPressed){ return; }
  const hues = _tessellator.getPaintHue();
  let uHue = hues.u;
  let lHue = hues.l;
  if(sliderFlag[0]){
    uHue = constrain(uHue + (mouseY - pmouseY)*0.01, 0, 1);
  }
  if(sliderFlag[1]){
    lHue = constrain(lHue + (mouseY - pmouseY)*0.01, 0, 1);
  }
  _tessellator.setPaintHue(uHue, lHue);
}

// --------------------------------------------------------------- //
// texture float usability check.
// RenderNode

// texture float
function textureFloatCheck(){
  let ext;
  ext = gl.getExtension('OES_texture_float') || this._renderer.getExtension('OES_texture_half_float');
  if(ext == null){
    alert('float texture not supported');
    return;
  }
}

// Uint32Array
function Uint32ArrayCheck(){
  if (!gl.getExtension('OES_element_index_uint')) {
    throw new Error('Unable to render a 3d model with > 65535 triangles. Your web browser does not support the WebGL Extension OES_element_index_uint.');
  }
}

// --------------------------------------------------------------- //
// global functions.

// framebuffer.
// framebuffer
// attribute
// RenderNode


 
  let textureFormat = null;
  if(!format){
    textureFormat = gl.UNSIGNED_BYTE;
  }else{
    textureFormat = format;
  }


  let frameBuffer = gl.createFramebuffer();


  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);

 
  let depthRenderBuffer = gl.createRenderbuffer();
  gl.bindRenderbuffer(gl.RENDERBUFFER, depthRenderBuffer);


  gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, w, h);


  gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthRenderBuffer);


  let fTexture = gl.createTexture();

  
  gl.bindTexture(gl.TEXTURE_2D, fTexture);


  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, textureFormat, null);

 
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, fTexture, 0);


  gl.bindTexture(gl.TEXTURE_2D, null);
  gl.bindRenderbuffer(gl.RENDERBUFFER, null);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);


 return {f : frameBuffer, d : depthRenderBuffer, t : fTexture};
}

// vbo
function create_vbo(data){

  let vbo = gl.createBuffer();

  
  gl.bindBuffer(gl.ARRAY_BUFFER, vbo);

 
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW);

  
  gl.bindBuffer(gl.ARRAY_BUFFER, null);

  return vbo;
}

// attribute
function set_attribute(attributes){
  
  for(let name of Object.keys(attributes)){
    const attr = attributes[name];
   
    gl.bindBuffer(gl.ARRAY_BUFFER, attr.vbo);

    // attributeLocation
    gl.enableVertexAttribArray(attr.location);

    // attributeLocation
    gl.vertexAttribPointer(attr.location, attr.stride, gl.FLOAT, false, 0, 0);
  }
}

// ibo
function create_ibo(data, type){
  // type:Uint16ArrayUint32Array.
 
  let ibo = gl.createBuffer();

  
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);


  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new (type)(data), gl.STATIC_DRAW);


  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);


  return ibo;
}

// utility.

function _RGB(r, g, b){
  if(arguments.length === 1){
    g = r;
    b = r;
  }
  return {r:r, g:g, b:b};
}

function _HSV(h, s, v){
  h = constrain(h, 0, 1);
  s = constrain(s, 0, 1);
  v = constrain(v, 0, 1);
  let _r = constrain(abs(((6 * h) % 6) - 3) - 1, 0, 1);
  let _g = constrain(abs(((6 * h + 4) % 6) - 3) - 1, 0, 1);
  let _b = constrain(abs(((6 * h + 2) % 6) - 3) - 1, 0, 1);
  _r = _r * _r * (3 - 2 * _r);
  _g = _g * _g * (3 - 2 * _g);
  _b = _b * _b * (3 - 2 * _b);
  let result = {};
  result.r = v * (1 - s + s * _r);
  result.g = v * (1 - s + s * _g);
  result.b = v * (1 - s + s * _b);
  return result;
}

// --------------------------------------------------------------- //
// UnionFind.

// 0,1,2,...,n-1query

function getUnionFind(n, query){
  let parent = [];
  let rank = [];
  for(let i = 0; i < n; i++){
    parent.push(i);
    rank.push(0);
  }
  function Find(a){
    if(parent[a] == a){
      return a;
    }else{
      parent[a] = Find(parent[a]);
      return parent[a];
    }
  }
  function Union(a, b){
    let aRoot = Find(a);
    let bRoot = Find(b);
    if(rank[aRoot] > rank[bRoot]){
      parent[bRoot] = aRoot;
    }else if(rank[bRoot] > rank[aRoot]){
      parent[aRoot] = bRoot;
    }else if(aRoot != bRoot){
      parent[bRoot] = aRoot;
      rank[aRoot] = rank[aRoot] + 1;
    }
  }
 for(let i = 0; i < 2; i++){
    for(let q of query){
      Union(q[0], q[1]);
    }
  }
  let uf = [];
  for(let i = 0; i < n; i++){
    uf.push({id:i, pt:parent[i]});
  }
  uf.sort((x, y) => {
    if(x.pt < y.pt){ return -1; }
    if(x.pt > y.pt){ return 1; }
    return 0;
  });
  uf[0].lv = 0;
  let count = 1;
  for(let i = 1; i < n; i++){
    if(uf[i].pt == uf[i-1].pt){
      uf[i].lv = uf[i-1].lv;
    }else{
      uf[i].lv = uf[i-1].lv + 1;
      count++;
    }
  }
  uf.sort((x, y) => {
    if(x.id < y.id){ return -1; }
    if(x.id > y.id){ return 1; }
    return 0;
  });
  return {uf:uf, count:count}; // count
}

// --------------------------------------------------------------- //
// RenderSystem class.
// shadeprogramtopologyset
// topology


class RenderSystem{
  constructor(name, _shader){
    this.name = name;
    this.shader = _shader;
    shader(_shader);
    this.program = _shader._glProgram;
    this.topologies = {};
    this.uniformLocations = {};
  }

getName(){
    return this.name;
  }
  registTopology(topologyName){
    if(this.topologies[topologyName] !== undefined){ return; }
    this.topologies[topologyName] = new Topology(topologyName);
  }
  getProgram(){
    return this.program;
  }
  getShader(){
    return this.shader;
  }
  getTopology(topologyName){
    return this.topologies[topologyName];
  }
  registUniformLocation(uniformName){
    if(this.uniformLocations[uniformName] !== undefined){ return; }
    this.uniformLocations[uniformName] = gl.getUniformLocation(this.program, uniformName);
  }
  setTexture(uniformName, _texture, locationID){
    gl.activeTexture(gl.TEXTURE0 + locationID);
    gl.bindTexture(gl.TEXTURE_2D, _texture);
    gl.uniform1i(this.uniformLocations[uniformName], locationID);
  }
}

// --------------------------------------------------------------- //
// RenderNode class.
// RenderSystem

class RenderNode{
  constructor(){
    this.renderSystems = {};
    this.currentRenderSystem = undefined;
    this.currentShader = undefined;
    this.currentTopology = undefined;
    this.useTextureFlag = false;
    this.tfMatrix = new p5.Matrix(); 
  
  }
  registRenderSystem(renderSystemName, _shader){
    if(this.renderSystems[renderSystemName] !== undefined){ return; }
    this.renderSystems[renderSystemName] = new RenderSystem(renderSystemName, _shader);
  }
  use(renderSystemName, topologyName){
   
    if(this.renderSystems[renderSystemName] == undefined){ return; }
    this.useRenderSystem(renderSystemName);
    this.registTopology(topologyName); 
    this.useTopology(topologyName);
    return this;
  }

 useRenderSystem(renderSystemName){
    
    this.currentRenderSystem = this.renderSystems[renderSystemName];
    this.currentShader = this.currentRenderSystem.getShader();
    this.currentShader.useProgram();
    return this;
  }
  registTopology(topologyName){
    // currentProgram
    this.currentRenderSystem.registTopology(topologyName);
  }
  useTopology(topologyName){

    this.currentTopology = this.currentRenderSystem.getTopology(topologyName);
    return this;
  }
  registAttribute(attributeName, data, stride){
    this.currentTopology.registAttribute(this.currentRenderSystem.getProgram(), attributeName, data, stride);
    return this;
  }
  registAttributes(attrData){
    for(let attrName of Object.keys(attrData)){
      const attr = attrData[attrName];
      this.registAttribute(attrName, attr.data, attr.stride);
    }
    return this;
  }
  setAttribute(){
    // topology
    this.currentTopology.setAttribute();
    return this;
  }
  registIndexBuffer(data, type){
    // Uint16Array. Uint32Array
    if(type === undefined){ type = Uint16Array; }
    this.currentTopology.registIndexBuffer(data, type);
    return this;
  }
  bindIndexBuffer(){
    this.currentTopology.bindIndexBuffer();
    return this;
  }
  registUniformLocation(uniformName){
    this.currentRenderSystem.registUniformLocation(uniformName);
    return this;
  }

 setTexture(uniformName, _texture, locationID){
    this.currentRenderSystem.setTexture(uniformName, _texture, locationID);
    this.useTextureFlag = true; // 1true
    return this;
  }
  setUniform(uniformName, data){
    this.currentShader.setUniform(uniformName, data);
    return this;
  }
  clear(){
    /
    // topology
    this.currentTopology.clear();
    // texture
    if(this.useTextureFlag){
      gl.bindTexture(gl.TEXTURE_2D, null);
      this.useTextureFlag = false;
    }
  }
  setMatrixStandard(uMV){
    // uMVuMVMatrix
    const sh = this.currentShader;
    sh.setUniform('uProjectionMatrix', _gl.uPMatrix.mat4);
    sh.setUniform('uModelViewMatrix', uMV.mat4);
    sh.setUniform('uViewMatrix', _gl._curCamera.cameraMatrix.mat4);
    _gl.uNMatrix.inverseTranspose(uMV);
    sh.setUniform('uNormalMatrix', _gl.uNMatrix.mat3);
  }
  setMatrix(tf){
    // uMVuPuViewuNormal(uNormal)
    let uMV = _gl.uMVMatrix.copy();
    if(tf !== undefined){
      this.transform(tf, uMV); // tf。tr, rotX, rotY, rotZ, scale.
      // rotAxis
    }
    this.setMatrixStandard(uMV);
    return this;
  }
  transform(tf, uMV){
   。
    for(let command of tf){
      const name = Object.keys(command)[0];
      const value = command[name];
      switch(name){
        case "tr":
         
          if(value.length === 1){ value.push(value[0], value[0]); }
          uMV.translate(value);
          break;

// rotX
        case "rotX":
          uMV.rotateX(value); break;
        case "rotY":
          uMV.rotateY(value); break;
        case "rotZ":
          uMV.rotateZ(value); break;
        case "rotAxis":
          
          uMV.rotate(...value); break;
        case "scale":
         
          if(value.length === 1){ value.push(value[0], value[0]); }
          uMV.scale(...value); break;
      }
    }
  }
  setVertexColor(){
    const sh = this.currentShader;
    sh.setUniform('uUseColorFlag', 0);
    return this;
  }
  setMonoColor(col, a = 1){
    const sh = this.currentShader;
    sh.setUniform('uUseColorFlag', 1);
    sh.setUniform('uMonoColor', [col.r, col.g, col.b, a]);
    return this;
  }
  setDirectionalLight(col, x, y, z){
    const sh = this.currentShader;
    sh.setUniform('uUseDirectionalLight', true);
    sh.setUniform('uDirectionalDiffuseColor', [col.r, col.g, col.b]);
    sh.setUniform('uLightingDirection', [x, y, z]);
    return this;
  }
  setAmbientLight(col){
    const sh = this.currentShader;
    sh.setUniform('uAmbientColor', [col.r, col.g, col.b]);
    return this;
  }
  setPointLight(col, x, y, z, att0 = 1, att1 = 0, att2 = 0){
    // att0,att1,att2attenuation（
    
    const sh = this.currentShader;
    sh.setUniform('uUsePointLight', true);
    sh.setUniform('uPointLightDiffuseColor', [col.r, col.g, col.b]);
    sh.setUniform('uPointLightLocation', [x, y, z]);
    sh.setUniform('uAttenuation', [att0, att1, att2]);
    return this;
  }
drawArrays(mode, first, count){
 
    if(arguments.length == 1){
      first = 0;
      count = this.currentTopology.getAttrSize();
    }
    gl.drawArrays(mode, first, count);
    return this;
  }
  drawElements(mode, count){
    // 大きい場合はgl.UNSIGNED_INTを指定
    const _type = this.currentTopology.getIBOType();
    const type = (_type === Uint16Array ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT);
   
    if(count === undefined){ count = this.currentTopology.getIBOSize(); }
    gl.drawElements(mode, count, type, 0);
    return this;
  }
  flush(){
    gl.flush();
    return this;
  }
}

// --------------------------------------------------------------- //
// Topology class.
// topologyset
class Topology{
  constructor(name){
    this.name = name;
    this.attributes = {}; // Object.keysdelete a[name]
    this.attrSize = 0;
    this.ibo = undefined;
    this.iboType = undefined;
    this.iboSize = 0;
  }
  getName(){
    return this.name;
  }
  getAttrSize(){
    return this.attrSize;
  }
  getIBOType(){
    return this.iboType;
  }
  getIBOSize(){
    return this.iboSize;
  }
  registAttribute(program, attributeName, data, stride){
    let attr = {};
    attr.vbo = create_vbo(data);
    attr.location = gl.getAttribLocation(program, attributeName);
    attr.stride = stride;
    this.attrSize = Math.floor(data.length / stride); // attr
    this.attributes[attributeName] = attr;
  }
 setAttribute(){
    set_attribute(this.attributes);
  }
  registIndexBuffer(data, type){
    this.ibo = create_ibo(data, type);
    this.iboType = type;
    this.iboSize = data.length; // ibo
  }
  bindIndexBuffer(){
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.ibo);
  }
  clear(){
    
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    if(this.ibo !== undefined){ gl.bindBuffer(gl.ELEMENT_BUFFER, null); }
    return this;
  }
}

// ------------------------------------------------------------ //
// computeNormals


// indices3*i,3*i+1,3*i+2
function getNormals(vertices, indices){
  let normals = [];
  for(let i = 0; i < Math.floor(vertices.length / 3); i++){
    normals.push(createVector(0, 0, 0));
  }
  let v0 = createVector();
  let v1 = createVector();
  let v2 = createVector();
  for(let i = 0; i < Math.floor(indices.length / 3); i++){
    const id = [indices[3*i], indices[3*i+1], indices[3*i+2]];
    v0.set(vertices[3*id[0]], vertices[3*id[0]+1], vertices[3*id[0]+2]);
    v1.set(vertices[3*id[1]], vertices[3*id[1]+1], vertices[3*id[1]+2]);
    v2.set(vertices[3*id[2]], vertices[3*id[2]+1], vertices[3*id[2]+2]);
    const w0 = p5.Vector.sub(v1, v0);
    const w1 = p5.Vector.sub(v2, v0);
    const w2 = p5.Vector.sub(v2, v1);
    const u0 = p5.Vector.cross(w0, w1);
    const u1 = p5.Vector.cross(w0, w2);
    const u2 = p5.Vector.cross(w1, w2);
    const m0 = w0.mag();
    const m1 = w1.mag();
    const m2 = w2.mag();
    const sin0 = u0.mag() / (m0 * m1);
    const sin1 = u1.mag() / (m0 * m2);
    const sin2 = u2.mag() / (m1 * m2);
    const angle0 = asin(sin0);
    const angle1 = asin(sin1);
    const angle2 = asin(sin2);
    const n = p5.Vector.normalize(u0);
    normals[id[0]].add(createVector(n.x*angle0, n.y*angle0, n.z*angle0));
    normals[id[1]].add(createVector(n.x*angle1, n.y*angle1, n.z*angle1));
    normals[id[2]].add(createVector(n.x*angle2, n.y*angle2, n.z*angle2));
  }
  
  let result = [];
  for(let n of normals){
    n.normalize();
    result.push(...n.array());
  }
  return result;
}

// ------------------------------------------------------ //
// rectangular.
// (-1,-1,1),(1,-1,1),(-1,1,1),(1,1,1),下。
function rectangular(sizeX, sizeY, sizeZ){
  if(arguments.length === 1){
    sizeY = sizeX;
    sizeZ = sizeX;
  }
  let v = [];
  for(let z = 1; z > -2; z -= 2){
    for(let y = -1; y < 2; y += 2){
      for(let x = -1; x < 2; x += 2){
        v.push(...[x * sizeX, y * sizeY, z * sizeZ]);
      }
    }
  }
  let f = [0,1,3,0,3,2,2,3,7,2,7,6,6,7,5,6,5,4,
           4,5,1,4,1,0,1,5,7,1,7,3,4,0,2,4,2,6];
 
  let n = getNormals(v, f);
  // 返す。
  return {v:v, f:f, n:n};
}

// ------------------------------------------------------ //
// spherical
function spherical(size, detailH = 8, detailV = 8){
  if(detailH < 8){ detailH = 8; }
  if(detailV < 8){ detailV = 8; }
  detailH = Math.floor(detailH);
  detailV = Math.floor(detailV);
  let v = [];
  let theta, phi;
  v.push(0, 0, size);
  for(let z = 1; z <= detailV - 1; z++){
    theta = PI * z / detailV; // あ、PIだ。
    for(let x = 0; x < detailH; x++){
      phi = TAU * x / detailH;
      v.push(size * sin(theta) * cos(phi),
             size * sin(theta) * sin(phi),
             size * cos(theta));
    }
  }
  v.push(0, 0, -size);
  
  // lu, ld, ru, rd
  
  let f = [];
  for(let i = 1; i <= detailH - 1; i++){
    f.push(0, i, i+1);
  }
  f.push(0, detailH, 1);
  let lu, ru, ld, rd;
  for(let k = 0; k <= detailV - 3; k++){
    for(let i = 1; i <= detailH - 1; i++){
      lu = i + 1 + k * detailH;
      ru = i + k * detailH;
      ld = i + 1 + (k + 1) * detailH;
      rd = i + (k + 1) * detailH;
      f.push(ru, rd, lu);
      f.push(lu, rd, ld);
    }
    lu = 1 + k * detailH;
    ru = detailH + k * detailH;
    ld = 1 + (k + 1) * detailH;
    rd = detailH + (k + 1) * detailH;
    f.push(ru, rd, lu);
    f.push(lu, rd, ld);
  }
 let k = detailV - 2;
  const bottom = Math.floor(v.length/3) - 1;
  for(let i = 1; i <= detailH - 1; i++){
    f.push(i + k * detailH, bottom, i + 1 + k * detailH);
  }
  f.push((k + 1) * detailH, bottom, 1 + k * detailH);

  let n = getNormals(v, f);
  return {v:v, f:f, n:n};
}

function parametricSurface(data, detailS = 2, detailT = 2){
  const curveFunc = data.func;
  const {s0, s1, t0, t1} = data;

  if(detailS < 2){ detailS = 2; }
  if(detailT < 2){ detailT = 2; }
  detailS = Math.floor(detailS);
  detailT = Math.floor(detailT);
  let v = [];
  let s, t, p;
  for(let k = 0; k <= detailT; k++){
    for(let i = 0; i <= detailS; i++){
      s = map(i, 0, detailS, s0, s1);
      t = map(k, 0, detailT, t0, t1);
      p = curveFunc(s, t);
      v.push(p.x, p.y, p.z);
    }
  }

  let f = [];
  let lu, ru, ld, rd;
  for(let k = 0; k < detailT; k++){
    for(let i = 0; i < detailS; i++){
      lu = i + (detailS + 1) * k;
      ru = i + 1 + (detailS + 1) * k;
      ld = lu + (detailS + 1);
      rd = ru + (detailS + 1);
      f.push(ru, rd, lu, lu, rd, ld);
    }
  }
  let n = getNormals(v, f);

  return {v:v, f:f, n:n};
}

function donut(longRadius, shortRadius, longDetail, shortDetail){
  
  let _data = {};
  _data.func = (s, t) => { return {x:(longRadius+shortRadius*sin(t))*sin(s), y:(80+20*sin(t))*cos(s), z:shortRadius*cos(t)}; }
  _data.s0 = -Math.PI;
  _data.s1 = Math.PI;
  _data.t0 = -Math.PI;
  _data.t1 = Math.PI;
  return parametricSurface(_data, longDetail, shortDetail);
}

  let _data = {};
  _data.func = (s, t) => { return {x:r*sin(s), y:r*cos(s), z:t}; }
  _data.s0 = -Math.PI;
  _data.s1 = Math.PI;
  _data.t0 = h * 0.5;
  _data.t1 = -h * 0.5;
  return parametricSurface(_data, detailR, detailH);
}


function polygon(r, detail = 3){
  if(detail < 3){ detail = 3; }
  detail = Math.floor(detail);
  let v = [];
  v.push(0, 0, 0);
  for(let i = 0; i < detail; i++){
    v.push(r * cos(TAU * i / detail), r * sin(TAU * i / detail), 0);
  }
  let f = [];
  for(let i = 1; i < detail; i++){
    f.push(0, i, i+1);
  }
  f.push(0, detail, 1);
  let n = getNormals(v, f);
  return {v:v, f:f, n:n};
}
