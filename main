let _gl, gl;
let lapse = 0;
let _if = 1;
let _skbg = 1;
let _node; 
let buttonLayer; 
let buttons = []; 

// tessellation
const MINIMUM_DISTANCE = 4;
let _drawer;
let _tessellator;

let hui;

let buttonRecipe =
    [{name:"delete", x:30, y:60, w:90, h:20, col:[78,100,100]},  // 0
    {name:"clear", x:30, y:90, w:90, h:20, col:[84,100,100]},
    {name:"create", x:30, y:140, w:90, h:40, col:[55,100,100]},
    {name:"reset", x:30,y:190, w:90, h:20, col:[45,100,100]},
    {name:"BOARD", x:30, y:240, w:90, h:20, col:[96,100,30]},    // 4
    {name:"BEVEL", x:30, y:270, w:90, h:20, col:[6,100,30]},
    {name:"DIMPLE", x:30, y:300, w:90, h:20, col:[16,100,30]},
    {name:"SPLIT", x:30, y:330, w:90, h:20, col:[26,100,30]},
    {name:"FIX", x:140, y:240, w:90, h:20, col:[46, 100, 30]},  
    {name:"ROLLING", x:140, y:270, w:90, h:20, col:[56, 100, 30]},
    {name:"MOVE", x:140, y:300, w:90, h:20, col:[40, 100, 30]}, // 10
    {name:"BOARD", x:30, y:240, w:90, h:20, col:[96,100,100]},   // 11
    {name:"BEVEL", x:30, y:270, w:90, h:20, col:[6,100,100]},
    {name:"DIMPLE", x:30, y:300, w:90, h:20, col:[16,100,100]},
    {name:"SPLIT", x:30, y:330, w:90, h:20, col:[26,100,100]},
    {name:"FIX", x:140, y:240, w:90, h:20, col:[46, 100, 100]},
    {name:"ROLLING", x:140, y:270, w:90, h:20, col:[56, 100, 100]},
    {name:"MOVE", x:140, y:300, w:90, h:20, col:[40, 100, 100]},   // 17
    {name:"CAMERA", x:140, y:60, w:90, h:50, col:[52, 100, 30]}, // 18
    {name:"CAMERA", x:140, y:60, w:90, h:50, col:[52, 100, 100]} // 19
   ];

// x:<235,y:55～125

let cameraFlag = false;


const MODE_BOARD = 0;
const MODE_BEVEL = 1;
const MODE_DIMPLE = 2;
const MODE_SPLIT = 3;
let sliderImg; 
let sliderFlag = [false, false]; 

// ACTION TYPE.
const ACTION_FIX = 0; 
const ACTION_ROLLING = 1; 
const ACTION_MOVE = 2; 


let posR = 320*Math.sqrt(3);
let defaultPosR = 320 * Math.sqrt(3);
let posTheta = Math.PI * 0.4;
let posPhi = Math.PI*0.66;
let focusX = 0;
let focusY = 0;
let eyeVector, toCenterVector, sideVector, upVector;

// --------------------------------------------------------------- //
// shader.

let lightVert=
"precision mediump float;" +

"attribute vec3 aPosition;" +
"attribute vec4 aVertexColor;" +
"attribute vec3 aNormal;" +

"uniform vec3 uAmbientColor;" +

"uniform mat4 uModelViewMatrix;" +
"uniform mat4 uProjectionMatrix;" +
"uniform mat3 uNormalMatrix;" +

"varying vec4 vVertexColor;" +
"varying vec3 vNormal;" +
"varying vec3 vViewPosition;" +
"varying vec3 vAmbientColor;" +

"void main(void){" +
 
"  vec4 viewModelPosition = uModelViewMatrix * vec4(aPosition, 1.0);" +

  // Pass varyings to fragment shader
"  vViewPosition = viewModelPosition.xyz;" +
"  gl_Position = uProjectionMatrix * viewModelPosition;" +

"  vNormal = uNormalMatrix * aNormal;" +
"  vVertexColor = aVertexColor;" +

"  vAmbientColor = uAmbientColor;" +
"}";

let lightFrag =
"precision mediump float;" +

"uniform mat4 uViewMatrix;" +
// directionalLight
"uniform vec3 uLightingDirection;" +
"uniform vec3 uDirectionalDiffuseColor;" +
"uniform vec3 uPointLightLocation;" +
"uniform vec3 uPointLightDiffuseColor;" +
"uniform vec3 uAttenuation;" + 
// pointLight
"uniform bool uUseDirectionalLight;" + // false.
"uniform bool uUsePointLight;" + // false;

"const float diffuseFactor = 0.73;" +
"const int USE_VERTEX_COLOR = 0;" +
"const int USE_MONO_COLOR = 1;" +
// DirectionalLight
"vec3 getDirectionalLightDiffuseColor(vec3 normal){" +
"  vec3 lightVector = (uViewMatrix * vec4(uLightingDirection, 0.0)).xyz;" +
"  vec3 lightDir = normalize(lightVector);" +
"  vec3 lightColor = uDirectionalDiffuseColor;" +
"  float diffuse = max(0.0, dot(-lightDir, normal));" +
"  return diffuse * lightColor;" +
"}" +
// PointLight attenuation
"vec3 getPointLightDiffuseColor(vec3 modelPosition, vec3 normal){" +
"  vec3 lightPosition = (uViewMatrix * vec4(uPointLightLocation, 1.0)).xyz;" +
"  vec3 lightVector = modelPosition - lightPosition;" +
"  vec3 lightDir = normalize(lightVector);" +
"  float lightDistance = length(lightVector); " +
"  float d = lightDistance;" +
"  float lightFallOff = 1.0 / dot(uAttenuation, vec3(1.0, d, d*d));" +
"  vec3 lightColor = lightFallOff * uPointLightDiffuseColor;" +
"  float diffuse = max(0.0, dot(-lightDir, normal));" +
"  return diffuse * lightColor;" +
"}" +
// _lightはこれで。
"vec3 totalLight(vec3 modelPosition, vec3 normal){" +
"  vec3 result = vec3(0.0);" + // 0.0
// directionalLight
"  if(uUseDirectionalLight){" +
"    result += getDirectionalLightDiffuseColor(normal);" +
"  }" +
// pointLight
"  if(uUsePointLight){" +
"    result += getPointLightDiffuseColor(modelPosition, normal);" +
"  }" +
"  result *= diffuseFactor;" +
"  return result;" +
"}" +
// include lighting.glsl
"uniform vec4 uMonoColor;" +
"uniform int uUseColorFlag;" + // 0:vertex. 1:mono.

"varying vec4 vVertexColor;" +
"varying vec3 vNormal;" +
"varying vec3 vViewPosition;" +
"varying vec3 vAmbientColor;" +
// メインコード
"void main(void){" +
"  vec3 diffuse = totalLight(vViewPosition, normalize(vNormal));" +
"  vec4 col = vec4(1.0);" +

"  if(uUseColorFlag == USE_MONO_COLOR) {" +
"    col = uMonoColor;" +  // uMonoColor
"  }" +
"  if(uUseColorFlag == USE_VERTEX_COLOR){" +
"    col = vVertexColor;" + 
"  }" +
  // diffuseの分
"  col.rgb *= (diffuse + vAmbientColor);" +
"  gl_FragColor = col;" +
"}";

let myVert=
"precision mediump float;" +
"attribute vec3 aPosition;" +
"attribute vec4 aVertexColor;" +
"varying vec4 vVertexColor;" +
"uniform mat4 uModelViewMatrix;" +
"uniform mat4 uProjectionMatrix;" +
"void main(){" +
"  vec4 viewModelPosition = uModelViewMatrix * vec4(aPosition, 1.0);" +
"  gl_Position = uProjectionMatrix * viewModelPosition;" +
"  vVertexColor = aVertexColor;" +
"}";

let myFrag=
"precision mediump float;" +
"varying vec4 vVertexColor;" +
"void main(){" +
"  gl_FragColor = vVertexColor;" +
"}";

const skyVert =
"precision mediump float;" +
"attribute vec3 aPosition;" +
"void main(){" +
"  gl_Position = vec4(aPosition, 1.0);" +
"}";
